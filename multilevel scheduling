
#include <stdio.h>
#include <stdlib.h>
#include<unistd.h>
int n,i,j,r=0,k=0,q2=0,t,flag,flag1;
void roundrobin();
void preemptive();
void sorting();
typedef struct Process
{
    int pid;
	int burst_time;
	int arrival_time;
	int ppriority;
	int start_time;
	int end_time;
	int waiting_time;

}process;
process p[200],q1[200],q3[200];//q1 and q3 are used to store processes in queue 200 each
//************************************************SORTING************************************************
void Sorting_arrival_time()
{

      process temporary;
      for(i = 0; i < n - 1; i++)
      {
            for(j = i + 1; j < n; j++)
            {
                  if(p[i].arrival_time> p[j].arrival_time)
                  {
                        temporary = p[i];
                        p[i] = p[j];
                        p[j] = temporary;
                  }
            }
      }
      int l;
      for(l=0;l<n;l++)
      {
//if two processes is having same arrivaltime and next process  has higher priority than prevoius processes
          if(p[l].arrival_time==p[l+1].arrival_time&&p[l].ppriority>p[l+1].ppriority)
            {
                temporary = p[l+1];
                p[l+1] = p[l];
                p[l] = temporary;
            }
      }
}
void sorting()
{
    process storetemp;
    for(i = 0; i < n - 1; i++)
      {
            for(j = i + 1; j < n; j++)
            {
                  if(p[i].ppriority> p[j].ppriority)
                  {
                        storetemp = p[i];
                        p[i] = p[j];
                        p[j] = storetemp;
                  }
                  if(q3[i].ppriority> q3[j].ppriority)
                  {
                        storetemp = q3[i];
                        q3[i] = q3[j];
                        q3[j] = storetemp;
                  }
            }
      }
}
//**************PREEMPTIVE priority scheduling*************
void preemptive_priority_scheduling()
{
    int c=n,a=0,flag=0;
    t=p[0].arrival_time;
   while(t>=0&&c>0)
   {
       //printf("We are at beginning of while loop\n");
        if (p[k].arrival_time < p[k+1].arrival_time&&p[k].burst_time>0)
           {
               if(p[k].burst_time==q3[k].burst_time)
                        q3[k].start_time=t;
            printf("Process P%d  :priority %d running at :time %d \n",p[k].pid,p[k].ppriority,t);
               p[k].burst_time=p[k].burst_time-1;
               if(p[k].burst_time==0&&p[k+1].ppriority < p[k].ppriority&&p[k+1].arrival_time > p[k].arrival_time&&p[k+1].arrival_time==t)
                {
                    k=k+1;
                    c--;
                    q3[k].end_time=t;
                }
                else if(p[k].burst_time==0)
                    {c--;
                    q3[k].end_time=t;
                    }
           }

        else if (p[k].arrival_time == p[k+1].arrival_time && p[k].ppriority < p[k+1].ppriority&&p[k].burst_time>0)
                {

                    if(p[k].burst_time==q3[k].burst_time)
                        q3[k].start_time=t;
                    printf("Process P%d   :priority %d running at   :time %d \n",p[k].pid,p[k].ppriority,t);
                    p[k].burst_time=p[k].burst_time-1;
                    if(p[k].burst_time==0)
                       {
                          c--;
                          q3[k].end_time=t;
                       }
                }
        else if(k==n-1&&p[k].burst_time>0)//if there are two processes present first will execute and last one is left out
            {
                if(p[k].burst_time==q3[k].burst_time)
                        q3[k].start_time=t;
                printf("Process P%d   :priority %d running at   :time %d \n",p[k].pid,p[k].ppriority,t);
                p[k].burst_time=p[k].burst_time-1;
                if(p[k].burst_time==0)
                 {c--;
                 q3[k].end_time=t;
                 }
                 if(c!=n-1&&c!=0&&p[k].burst_time==0||(c==1&&p[k].burst_time==0))
				 //code for if processes are left due to lower priority but not preempted 
                 {
                     int l,m;
                     for(l=0;l<n;l++)
                        {
                            sorting();
                            if(p[l].burst_time==q3[l].burst_time)
                            {
                                for(m=0;p[l].burst_time>0;m++)
                            {
                                t++;
                                if(p[l].burst_time==q3[l].burst_time)
                                        q3[l].start_time=t;
                                printf("Process P%d   :priority %d running at   :time %d \n",p[i].pid,p[i].ppriority,t);
                                p[l].burst_time=p[l].burst_time-1;
                                if(p[l].burst_time==0)
                                {
                                    q3[l].end_time=t;
                                    c--;
                                }
                            }
                            }
                        }
                        c=0;
                 }
            }
            else if(c!=0&&c!=n-1)
	
                {
                    flag1=1;
                    roundrobin();
                    if(p[k+1].ppriority<p[k].ppriority&&p[k].arrival_time>=t)
				
                    k=k+1;
                    if(k!=n-1&&p[k].arrival_time>t)
                        {
                            t=p[k].arrival_time;
                            t--;
                        }
                }
            ++t;
            for(a=k+1;a<n;a++)//checking if another process has come at that particular time
            {
                if(p[a].arrival_time==t&&flag==0)//flag to check there are no two process with same arrival time donot alter k value
               {
                if(p[a].ppriority < p[k].ppriority&&p[a].arrival_time > p[k].arrival_time||(p[a].ppriority==p[k+1].ppriority||p[a].ppriority==p[k].ppriority)&&p[a].arrival_time>p[k+1].arrival_time)
                   {
                       if(p[k].burst_time>0)
                       {
                       q1[q2]=p[k];
                       q2++;
                       r++;
                       c--;
                       }
                       k=a;
                       flag=1;
                   }
               }
            }
            flag=0;
   }
}
//**********************Round Robin**********
void roundrobin()
{
    int tf=0,tf1=0,tr1=0,td=0,td1=0,x=r,tw=0,flag2=0;
    if(flag1==1)
     while(t>0&&x>0&&p[k+1].arrival_time>t&&flag2==0)
    {
        if(flag2==0)
                {
                    if(q1[tr1].burst_time>0)
                    {
                    printf("Process P%d   :priority %d running at   :time %d \n",q1[tr1].pid,q1[tr1].ppriority,t);
                    q1[tr1].burst_time=q1[tr1].burst_time-1;
                    t++;
                    if(p[k+1].arrival_time==t)
                        {flag2==1;
                        t=p[k+1].arrival_time;
                            t--;
							goto b;
							}

                    if(q1[tr1].burst_time==0)
                      {
                          for(tw=0;tw<n;tw++)
                          {
                              if(q3[tw].pid==q1[tr1].pid)
                                q3[tw].end_time=t-1;
                          }
                         x--;
                         if(x==0)
                            r--;
                         
                      }
                    }
                    ++tf;
                    if(tf>=2)
                    {
                        if(tr1<x)
                            ++tr1;
                        else
                            tr1=0;
                        tf=0;
                    }
                }
    }

     if(flag1==0)
       while(t>0&&r>0)
    {
            if(flag2==0)
                {
                    if(q1[tr1].burst_time>0)
                    {
                    printf("Process P%d   :priority %d running at   :time %d \n",q1[tr1].pid,q1[tr1].ppriority,t);
                    q1[tr1].burst_time=q1[tr1].burst_time-1;
                    t++;
                    if(q1[tr1].burst_time==0)
                    {
                         for(tw=0;tw<n;tw++)
                          {
                              if(q3[tw].pid==q1[tr1].pid)
                                q3[tw].end_time=t-1;
                          }
                        r--;
                    }
                    }
                    ++tf1;
                    if(tf1>=2)
                    {
                        if(tr1<r)
                            ++tr1;
                        else
                            tr1=0;
                        tf1=0;
                    }
                }
    }
    b: printf("");
}
//*************************************************
int main()
{

    printf("\n\n\n*****************************************Multilevel Queue Scheduling*************************************\n\n\n");
    printf("How many processes    :\n");
    scanf("%d",&n);
    for(i =0;i<n;i++)
    {
    x: fflush(stdin);
        printf("Enter Process Number %d: \n",i);
        printf("Enter Burst Time in multiples  of 2:\n");
        scanf("%d",&p[i].burst_time);
        if(p[i].burst_time%2!=0||p[i].burst_time==1)
            goto x;
        printf("Arrival Time:\n");
        scanf("%d",&p[i].arrival_time);
        printf("Priority    :\n");
        scanf("%d",&p[i].ppriority);
        p[i].pid=i;


    }
    Sorting_arrival_time();//arrival time sorting
    for(i=0;i<n;i++)
    {
        q3[i]=p[i];
     printf("Process  : Burst_time  Arrival_time: Ppriority: and Process_id P\n");   
     for(i=0;i<n;i++)
    {
        printf("   :P%d\t\t%d\t\t%d\t%d\t\tP%d\n",i+1,p[i].burst_time,p[i].arrival_time,p[i].ppriority,p[i].pid);
    }

    preemptive_priority_scheduling();
    int x1=r;
    flag1=0;
    roundrobin();
    int z=0,totalburst_time;
    float turnaroundt,avgwaiting_time=0.0;
    for(z=0;z<n;z++)
    {
        //printf("Process P%d: endt %d startt:%d bursst:%d and process id P%d\n",z+1,q3[z].endt,q3[z].startt,q3[z].burstt,q3[z].pid);
        q3[z].waiting_time=q3[z].end_time-q3[z].start_time-q3[z].burst_time+1;
        avgwaiting_time=avgwaiting_time+q3[z].waiting_time;
        totalburst_time=q3[z].burst_time;
    }
    printf("\n\nAverage waiting time .......%f \n",avgwaiting_time/n);
    printf("\nAverage Turnaround time .......%f \n",(avgwaiting_time/n)+totalburst_time);
    return 0;
}

}
